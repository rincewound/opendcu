use barracuda_core::core::channel_manager::*;
use barracuda_core::dcm::*;
use barracuda_core::io::*;
use barracuda_core::profile::*;

use serde::{Deserialize, Serialize};

mod electricstrike;
mod accessgranted;
mod outputcomponentbase;
mod framecontact;

pub mod serialization_types;

use serialization_types::*;

#[derive(Copy, Clone, PartialEq, Serialize, Deserialize)]
pub enum DoorEvent
{
    Opened,                 // Triggered by FC
    Closed,                 // Triggered by FC
    ForcedOpen,             // Triggered by FC
    _OpenTooLong,           // Generated by TBD (alarm generator of some sort)
    DoorOpenAlarm,          // Generated by TBD (alarm generator of some sort)
    ReleasedPermanently,    // Generated by Profile Change
    ReleaseOnce,            // Generated on Access Request
    NormalOperation,        // Generated by Profile Change
    _Block
}

pub trait InputComponent: Send
{
    fn on_input_change(&mut self, event: &InputEvent, generated_events: &mut Vec<DoorEvent>);
    fn on_door_event(&mut self, event: DoorEvent, generated_events: &mut Vec<DoorEvent>);
}

pub trait OutputComponent: Send
{
    fn on_profile_change(&mut self, event: &ProfileChangeEvent, generated_events: &mut Vec<DoorEvent>);
    fn on_door_event(&mut self, event: DoorEvent, generated_events: &mut Vec<DoorEvent>);
}
pub trait VirtualComponent: Send
{
    fn on_door_event(&mut self, event: DoorEvent, generated_events: &mut Vec<DoorEvent>);
}


pub struct Passageway
{
    id: u32,
    door_open_profile_id: u32,
    input_components: Vec<Box<dyn InputComponent>>,
    output_components: Vec<Box<dyn OutputComponent>>,
    virtual_components: Vec<Box<dyn VirtualComponent>>,
    pending_events: Vec<DoorEvent>,
}

impl Passageway
{
    fn load_input_components(components: Vec<InputComponentSerialization>) -> Vec<Box<dyn InputComponent>>
    {
        for component in components.iter()
        {
            match component
            {
                InputComponentSerialization::FrameContact(setting) => {}                
                _ => {panic!("Unknown input component type!")}
            }
        }
        vec![]
    }

    fn load_output_components(components: Vec<OutputComponentSerialization>) -> Vec<Box<dyn OutputComponent>>
    {
        for component in components.iter()
        {
            match component
            {
                OutputComponentSerialization::ElectricStrike(setting) => {}
                OutputComponentSerialization::AccessGranted(setting) => {}
                _ => {panic!("Unknown output component type!")}
            }
        }
        vec![]
    }

    pub fn new(settings: PassagewaySetting) -> Self
    {
        Self 
        {
            id: settings.id,
            door_open_profile_id: 0,
            input_components: Passageway::load_input_components(settings.inputs),
            output_components: Passageway::load_output_components(settings.outputs),
            virtual_components: vec![],
            pending_events: vec![]
        }
    }

    pub fn on_profile_change(&mut self, event: &ProfileChangeEvent)
    {
        for v in self.output_components.iter_mut()
        {
            v.on_profile_change(event, &mut self.pending_events);
        }

        // if the profile is our door open profile, we have
        // to adjust the doorstate here as well
        if event.profile_id == self.door_open_profile_id
        {
            if event.profile_state == ProfileState::Active
            {
                self.handle_door_event(DoorEvent::ReleasedPermanently);
            }
            if event.profile_state == ProfileState::Inactive
            {
                self.handle_door_event(DoorEvent::NormalOperation);
            }
        }
        self.do_events();
    }

    pub fn on_input_change(&mut self, event: &InputEvent)
    {
        for v in self.input_components.iter_mut()
        {
            v.on_input_change(event, &mut self.pending_events);
        }
        self.do_events();
    }

    pub fn handle_door_event(&mut self, event: DoorEvent)
    {
        for v in self.output_components.iter_mut()
        {
            v.on_door_event(event, &mut self.pending_events);
        }

        for v in self.input_components.iter_mut()
        {
            v.on_door_event(event, &mut self.pending_events);
        }

        for v in self.virtual_components.iter_mut()
        {
            v.on_door_event(event, &mut self.pending_events);
        }
        self.do_events();   
    }

    pub fn on_door_open_request(&mut self, request: &DoorOpenRequest)
    {
        // Check if AP belongs to this door

        // Check doorstate: If we're blocked, signal this, otherwise
        // signal access granted here and release the door.

        self.handle_door_event(DoorEvent::ReleaseOnce);
    }

    fn do_events(&mut self)
    {
        while let Some(evt) = self.pending_events.pop()
        {
            self.handle_door_event(evt);
        }
    }
}
